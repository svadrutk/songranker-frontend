<img src="https://r2cdn.perplexity.ai/pplx-full-logo-primary-dark%402x.png" style="height:64px;margin-right:32px"/>

# Testing & Verification Plan for Song Ranker/Chorusboard

**Project Summary**: This document provides a comprehensive testing plan with viability assessments and step-by-step instructions for each test case.

## üéØ Testing Priority Guide

**Start Here (Critical Path)**:
1. **API Integration Testing** - Core functionality depends on this
2. **Deduplication Logic Testing** - Prevents user frustration with duplicates
3. **Ranking Algorithm Verification** - Core feature, must work correctly
4. **Session Management Testing** - Users need to save/resume work
5. **Error Handling Testing** - Ensures graceful failures

**Next (Important)**:
6. **Frontend UX Testing** - User experience polish
7. **Database Testing** - Data integrity critical
8. **Backend Worker Testing** - Background processing reliability

**Then (Polish)**:
9. **Social Sharing Testing** - Growth feature
10. **Cross-Browser Testing** - Compatibility
11. **Security Testing** - Protection against attacks

**Legend**:
- ‚úÖ **VIABLE** - Ready to test, implementation exists
- ‚ö†Ô∏è **NEEDS VERIFICATION** - May need setup or configuration
- ‚ùå **NOT IMPLEMENTED** - Feature doesn't exist yet

---

## üìã Document cross-check (repo status)

*Last cross-checked against repo: Jan 2025.*

| Area | Status | Notes |
|------|--------|--------|
| **API paths** | ‚úÖ Current | `app/api/v1/search.py`, `app/clients/musicbrainz.py`, `app/core/limiter.py` exist. `GET /tracks/{release_group_id}` in `search.py`. |
| **SongInput** | ‚úÖ Current | `lib/api.ts`: `name`, `artist`, `album?`, `spotify_id?`, `cover_url?`. No `duration` (doc note correct). |
| **Deduplication** | ‚úÖ Current | `lib/deduplication.ts`: `normalizeTitle()`, `SUFFIXES_REGEX`, `calculateSimilarity` > 85, `prepareSongInputs` (shortest name canonical). `DeduplicationModal.tsx`: toggle Merge / Keep both, `matchIndices`. |
| **Ranking** | ‚úÖ Current | `RankingWidget` uses `getNextPair` (`lib/pairing.ts`), `convergence_score`, `bt_strength`. Bradley‚ÄìTerry in `app/tasks.py` (`process_ranking_update`). **Change**: ranking update runs **in-process** every 5 duels via `background_tasks.add_task(process_ranking_update, ...)` in `sessions.py`; RQ worker still used for `run_deep_deduplication` and `run_global_ranking_update`. |
| **Rate limiting** | ‚úÖ Current | `slowapi` in `app/core/limiter.py`. Limits: search 30/min, create session 10/min, feedback 5/min, image generation 5/min, leaderboard 60/min. |
| **Share card** | ‚ö†Ô∏è **Updated** | **No longer client-side.** Share image is generated by backend `POST /generate-receipt` (`app/api/v1/image_generation.py`). Frontend `ShareButton` + `lib/share-actions.ts` call backend; no `html-to-image` in share flow (package still in repo). `ShareVisual` is used for preview; image bytes come from backend. |
| **Sessions / RLS** | ‚ö†Ô∏è Unchanged | Backend `get_session_detail(session_id)` does not check `user_id`; isolation relies on Supabase RLS or auth. RLS verified only on `feedback` table (`supabase_feedback.sql`); sessions table RLS still **NEEDS VERIFICATION**. |
| **beforeunload** | ‚ùå Not implemented | No `beforeunload` in frontend; doc recommendation still valid. |
| **fetchBackend timeout** | ‚ö†Ô∏è Unchanged | No explicit timeout in `lib/api.ts` `fetchBackend()`. `share-actions.ts` uses `AbortSignal.timeout(30000)` for `/generate-receipt` only. |
| **Export / Undo** | ‚ùå Not implemented | No data export or undo comparison in repo; doc recommendations still valid. |
| **Global leaderboard** | ‚úÖ Current | `GlobalLeaderboard.tsx` exists; backend `GET /leaderboard/{artist}` and `GET /leaderboard/{artist}/stats` in `app/api/v1/leaderboard.py`. |
| **Locust** | ‚úÖ Current | `songranker-backend/locustfile.py` exists (search, tracks, health). |
| **DELETE session** | ‚úÖ Current | `DELETE /sessions/{session_id}` in backend; `deleteSession()` in `lib/api.ts`; `SessionSelector` calls it. |

---

Based on your Song Ranker/Chorusboard project, here's a comprehensive testing and verification plan organized by component areas:[^1]

## API Integration Testing

**Test MusicBrainz API search and data retrieval**

- Search for various artists with common names (e.g., "Michael Jackson", "The Beatles") and verify results are accurate
  - ‚úÖ **VIABLE** - Backend uses MusicBrainz + Last.fm + Spotify APIs (`app/clients/musicbrainz.py`, `app/api/v1/search.py`)
  - **How to test**: Use the search box in `Catalog.tsx`, try "The Beatles", "Michael Jackson", "Taylor Swift"
  - **Verify**: Results show albums with correct artist names and cover art
  - **Check**: Open browser DevTools Network tab to see `/search` API calls

- Test edge cases: artists with special characters, non-English names, and very long names
  - ‚úÖ **VIABLE** - Backend handles merging from multiple sources (`_merge_results` function)
  - **How to test**: Search for "Franz Ferdinand", "Sigur R√≥s", "The 1975", "Beyonc√©"
  - **Verify**: Special characters display correctly, no encoding issues
  - **Note**: Backend normalizes and merges results from MusicBrainz + Last.fm

- Search for albums and verify correct songs are returned for each album
  - ‚úÖ **VIABLE** - `GET /tracks/{release_group_id}` endpoint exists
  - **How to test**: Click an album in search results, verify track list appears
  - **Verify**: Songs match the album, no duplicates, correct order
  - **Check**: Backend uses MusicBrainz release groups (`app/api/v1/search.py:get_tracks`)

- Test rate limiting behavior if you make many requests quickly
  - ‚úÖ **VIABLE** - Backend has rate limiting (`app/core/limiter.py`, `slowapi` with 5/min on feedback)
  - **How to test**: Rapidly search 10+ times in quick succession
  - **Verify**: Check if requests are throttled or if errors appear
  - **Note**: Rate limits are per-endpoint: search 30/min, create session 10/min, feedback 5/min, image generation 5/min, leaderboard 60/min (`@limiter.limit()` in respective routers).
  - **Check backend logs**: Look for rate limit errors in FastAPI logs

- Verify the API gracefully handles network timeouts or unavailable services
  - ‚úÖ **VIABLE** - Frontend has error handling (`lib/api.ts:fetchBackend`, `ErrorBanner` component)
  - **How to test**: 
    1. Disconnect internet, try searching ‚Üí should show error banner
    2. Stop backend server (`uvicorn`), try API calls ‚Üí should show "Cannot reach backend"
  - **Verify**: Error messages are user-friendly, no crashes
  - **Note**: Frontend shows `ErrorBanner` component for connection failures

- Check that song metadata (title, artist, album, duration) is correctly extracted and stored
  - ‚úÖ **VIABLE** - Songs stored in Supabase with metadata (`SongInput` type)
  - **How to test**: Create a session, check database or session detail API response
  - **Verify**: `name`, `artist`, `album`, `cover_url` fields are populated
  - **Note**: Duration not currently stored (check `SongInput` type - no duration field)
  - **Check**: Query Supabase `songs` table or use `GET /sessions/{id}` endpoint


## Deduplication Logic Testing

**Validate fuzzy matching identifies duplicate songs correctly**

- Create test cases with intentional duplicates: "Song Title (Album Version)" vs "Song Title" vs "Song Title - Remastered"
  - ‚úÖ **VIABLE** - Frontend deduplication in `lib/deduplication.ts` with `normalizeTitle()` and `SUFFIXES_REGEX`
  - **How to test**: 
    1. Search for an artist with multiple album versions (e.g., "Taylor Swift - 1989")
    2. Select both "1989" and "1989 (Taylor's Version)" albums
    3. Check `DeduplicationModal` - should group duplicates with 85%+ similarity
  - **Verify**: Songs like "Shake It Off" and "Shake It Off (Remastered)" are grouped
  - **Check**: `normalizeTitle()` strips remastered/live/instrumental suffixes (`SUFFIXES_REGEX`)

- Test songs with featuring artists written differently: "ft.", "feat.", "featuring", "\&"
  - ‚ö†Ô∏è **PARTIALLY VIABLE** - Normalization strips punctuation but may not handle feat. variations well
  - **How to test**: Create a test session with songs like:
    - "Song ft. Artist"
    - "Song feat. Artist"  
    - "Song featuring Artist"
  - **Verify**: Check if these are grouped as duplicates (they might not be - this could be a gap)
  - **Note**: `normalizeTitle()` removes punctuation but doesn't normalize "ft"/"feat"/"featuring"
  - **Recommendation**: May need enhancement to normalize featuring artist markers

- Add songs from different albums (live version, deluxe edition, single) and verify correct merging
  - ‚úÖ **VIABLE** - Deduplication works across albums (`prepareSongInputs` uses normalized title + artist)
  - **How to test**: Select songs from "Album (Deluxe)", "Album (Live)", and "Album" - same song should merge
  - **Verify**: `DeduplicationModal` shows grouped duplicates before session starts
  - **Check**: Uses index-based tracking (`matchIndices`) to prevent removing all instances

- Test false positive prevention: songs with similar but different titles should NOT merge
  - ‚úÖ **VIABLE** - Similarity threshold is 85% (`calculateSimilarity` function)
  - **How to test**: Create session with:
    - "Love Story" vs "Love Story (Taylor's Version)" ‚Üí should merge
    - "Love Story" vs "Love Me" ‚Üí should NOT merge (different songs)
  - **Verify**: Check `DeduplicationModal` - only true duplicates grouped
  - **Note**: Length check optimization (`minLength / maxLength < 0.7`) prevents false matches

- Verify user can manually override merge decisions during the duplicate review step
  - ‚úÖ **VIABLE** - `DeduplicationModal.tsx` has "Merge" and "Keep Both" buttons
  - **How to test**: 
    1. When duplicates are shown, click "Keep Both" for a group
    2. Verify both songs appear in final session
    3. Try "Merge" - verify only canonical song remains
  - **Verify**: User choices are respected, no data loss
  - **Check**: Modal uses `matchIndices` to track which songs to remove

- Check that merged songs retain all relevant metadata from both versions
  - ‚ö†Ô∏è **NEEDS VERIFICATION** - `prepareSongInputs` prefers shortest name as canonical
  - **How to test**: Merge "Song (Remastered)" with "Song", check which metadata is kept
  - **Verify**: Check `SongInput` - should have `cover_url`, `album`, `artist` from best source
  - **Note**: Code prefers shorter name but may lose metadata from longer version
  - **Potential issue**: Cover art from remastered version might be lost if shorter name wins


## Ranking Algorithm Verification

**Ensure Elo and Bradley-Terry calculations produce accurate rankings**

- Create a controlled test session with known preferences (e.g., rank 10 songs where you know the intended order)
  - ‚úÖ **VIABLE** - Can create test sessions via `POST /sessions` API
  - **How to test**: 
    1. Create session with 10 songs you know your preference order for
    2. Make comparisons following your known order (always pick your preferred song)
    3. Complete session and check final ranking
  - **Verify**: Final ranking matches your intended order (within statistical tolerance)
  - **Tools**: Use browser DevTools to monitor API calls, check `convergence_score` progress

- Make comparisons systematically and verify final rankings match expectations within reasonable tolerance
  - ‚úÖ **VIABLE** - Both Elo (frontend) and Bradley-Terry (backend) are implemented
  - **How to test**: 
    1. Make 20-30 comparisons for 10 songs
    2. Check `Leaderboard` component shows rankings sorted by `bt_strength`
    3. Compare with your known preferences
  - **Verify**: Rankings are reasonable (top 3 should match your top 3, even if order differs slightly)
  - **Note**: Bradley-Terry handles contradictions probabilistically - perfect match unlikely

- Test edge case: rank 2 songs (minimum) and verify the system handles it correctly
  - ‚úÖ **VIABLE** - Minimum session size should work
  - **How to test**: Create session with exactly 2 songs, make 1 comparison
  - **Verify**: 
    - Session completes successfully
    - Rankings show #1 and #2
    - No errors in console
  - **Check**: Backend handles minimum case (`app/tasks.py` Bradley-Terry calculation)

- Test convergence: make 20 comparisons for 50 songs, then make 30 more, and verify rankings stabilize
  - ‚úÖ **VIABLE** - Convergence tracking exists (`convergence_score` 0-100%)
  - **How to test**: 
    1. Create 50-song session
    2. Make 20 comparisons, note top 10
    3. Make 30 more comparisons, check if top 10 changed significantly
  - **Verify**: `convergence_score` increases, rankings become more stable
  - **Check**: Progress bar in `RankingWidget` shows convergence percentage
  - **Note**: Convergence typically reaches 90%+ after sufficient comparisons

- Verify Elo ratings update immediately in the frontend after each comparison
  - ‚úÖ **VIABLE** - Optimistic updates in `RankingWidget.tsx` using `calculateNewRatings`
  - **How to test**: 
    1. Make a comparison, immediately hover over song cards
    2. Check `local_elo` values updated without waiting for API response
  - **Verify**: Elo numbers change instantly, no delay
  - **Check**: `RankingCard` displays `local_elo` on hover, updates optimistically

- Check that Bradley-Terry backend calculations eventually converge (progress reaches 100%)
  - ‚úÖ **VIABLE** - Backend calculates BT strengths, returns `convergence_score`
  - **How to test**: 
    1. Make comparisons until convergence reaches 90%+
    2. Check `GET /sessions/{id}` response includes `convergence_score`
    3. Verify it increases over time
  - **Verify**: Convergence reaches high percentage (90%+) after sufficient comparisons
  - **Check**: `app/tasks.py` has `process_ranking_update` (async). It is run **in-process** every 5 duels via `background_tasks.add_task(process_ranking_update, ...)` in `sessions.py`; RQ worker (`worker.py`) is still used for `run_deep_deduplication` and `run_global_ranking_update`.
  - **Note**: Frontend polls for updates with exponential backoff (0ms, 400ms, 800ms, 1.5s, 2.5s)

- Test transitivity violations: if A > B and B > C, but you choose C > A, verify the system handles this gracefully
  - ‚úÖ **VIABLE** - Bradley-Terry model handles contradictions probabilistically
  - **How to test**: 
    1. Create session with 3 songs: A, B, C
    2. Choose A > B, then B > C
    3. Intentionally choose C > A (violating transitivity)
    4. Complete session and check rankings
  - **Verify**: System doesn't crash, produces reasonable ranking despite contradiction
  - **Note**: BT model treats choices as statistical observations, weights by frequency
  - **Expected**: Final ranking reflects majority of choices, handles contradictions gracefully


## Session Management Testing

**Test save, resume, and persistence functionality**

- Create a session, make 10 comparisons, close the browser, and verify you can resume from the same state
  - ‚úÖ **VIABLE** - Sessions stored in Supabase, `SessionSelector` loads past sessions
  - **How to test**: 
    1. Create session, make 10 comparisons
    2. Close browser completely
    3. Reopen, go to "My Sessions", select the session
    4. Verify it resumes with same songs and comparison count
  - **Verify**: `comparison_count` matches, songs list intact, can continue ranking
  - **Check**: `getUserSessions()` API returns session summaries with metadata

- Test creating multiple sessions simultaneously for different artists/albums
  - ‚úÖ **VIABLE** - Multiple sessions supported per user
  - **How to test**: 
    1. Create session for "Taylor Swift"
    2. Create another session for "The Beatles" (without closing first)
    3. Check "My Sessions" shows both
  - **Verify**: Both sessions appear, can switch between them
  - **Check**: `SessionSelector` component loads all user sessions via `getUserSessions()`

- Verify session IDs are unique and cannot be guessed or accessed by unauthorized users
  - ‚úÖ **VIABLE** - Sessions use UUIDs, Supabase RLS should protect access
  - **How to test**: 
    1. Create session, note the UUID from URL or API response
    2. Try accessing another user's session ID: `GET /sessions/{other_user_session_id}`
    3. Should fail with 403/404 if RLS is configured
  - **Verify**: Cannot access other users' sessions
  - **Check**: Supabase RLS policies on `sessions` table (may need verification - see Database Testing)
  - **Note**: UUIDs are cryptographically random, hard to guess

- Test session expiration if applicable‚Äîverify old sessions are handled appropriately
  - ‚ö†Ô∏è **NEEDS VERIFICATION** - No expiration logic visible in code
  - **How to test**: 
    1. Check if old sessions (weeks/months old) still load
    2. Verify no errors when accessing old sessions
  - **Verify**: Old sessions remain accessible (or gracefully handled if expired)
  - **Note**: May need to implement expiration policy if desired
  - **Check**: Database schema - no `expires_at` field visible

- Create a session, log out (if authentication exists), log back in, and verify session persists
  - ‚úÖ **VIABLE** - Supabase Auth implemented (`AuthProvider`, `AuthModal`)
  - **How to test**: 
    1. Log in, create session, make comparisons
    2. Log out (via Supabase auth)
    3. Log back in with same account
    4. Check "My Sessions" - session should still be there
  - **Verify**: Sessions persist across login/logout cycles
  - **Check**: Sessions linked to `user_id` in database, not browser session

- Test session data integrity: verify comparison history, song list, and current rankings are all preserved
  - ‚úÖ **VIABLE** - All data stored in Supabase tables
  - **How to test**: 
    1. Create session, make 5 comparisons
    2. Note the songs and their current Elo/BT strengths
    3. Close and reopen session
    4. Verify: same songs, same comparison count, rankings preserved
  - **Verify**: `GET /sessions/{id}` returns complete session state
  - **Check**: Database tables (`sessions`, `songs`, `comparisons`) maintain relationships


## Frontend UX Testing

**Validate optimistic UI updates and user interactions**

- Make rapid consecutive comparisons and verify the UI doesn't lag or show stale data
  - ‚úÖ **VIABLE** - Optimistic updates prevent lag
  - **How to test**: Rapidly click through 10+ comparisons in quick succession
  - **Verify**: 
    - UI responds instantly to each click
    - No lag or freezing
    - Cards update smoothly
  - **Check**: Browser DevTools Performance tab - should show smooth 60fps
  - **Note**: Optimistic Elo updates happen immediately, API calls are async

- Verify rankings update visually after each comparison without requiring page refresh
  - ‚úÖ **VIABLE** - React state updates trigger re-renders
  - **How to test**: Make comparison, check `Leaderboard` component updates
  - **Verify**: Rankings reorder without page refresh
  - **Check**: `RankingWidget` updates `songs` state after each comparison
  - **Note**: Uses `setSongs()` to update state, React handles re-rendering

- Test the adaptive pairing logic: after 10+ comparisons, verify you're seeing songs with similar current rankings
  - ‚úÖ **VIABLE** - `lib/pairing.ts` implements adaptive pairing
  - **How to test**: 
    1. Make 10+ comparisons
    2. Note the Elo/BT strengths of pairs shown
    3. Verify pairs have similar ratings (within ~100-200 points)
  - **Verify**: Pairs are close in rating, not random
  - **Check**: `getNextPair()` function selects pairs with similar strengths
  - **Note**: Uses BT strengths when available, falls back to Elo

- Test responsive design on mobile, tablet, and desktop screen sizes
  - ‚úÖ **VIABLE** - Tailwind CSS responsive classes used
  - **How to test**: 
    1. Use browser DevTools responsive mode
    2. Test: mobile (375px), tablet (768px), desktop (1920px)
    3. Check layout, button sizes, text readability
  - **Verify**: Layout adapts, no horizontal scrolling, buttons accessible
  - **Check**: Components use Tailwind breakpoints (`sm:`, `md:`, `lg:`)

- Verify all buttons, navigation, and interactions work smoothly without errors in browser console
  - ‚úÖ **VIABLE** - Check browser DevTools Console
  - **How to test**: 
    1. Open DevTools Console
    2. Perform all actions: search, select albums, deduplicate, rank, share
    3. Check for errors/warnings
  - **Verify**: No unhandled errors, warnings are acceptable
  - **Check**: Look for React warnings, API errors, undefined values

- Test back button behavior: verify you can't accidentally lose progress
  - ‚ö†Ô∏è **NEEDS VERIFICATION** - No explicit back button handling visible
  - **How to test**: 
    1. During ranking session, click browser back button
    2. Verify: session state preserved or warning shown
  - **Verify**: Progress not lost, or clear warning before leaving
  - **Note**: May need `beforeunload` event handler to prevent accidental navigation
  - **Recommendation**: Add confirmation dialog if user tries to leave mid-session

- Check loading states appear appropriately during background calculations
  - ‚úÖ **VIABLE** - Loading states in `RankingWidget` (`isLoading` state)
  - **How to test**: 
    1. Make comparison, watch for loading indicators
    2. Check during BT sync polling (should show progress)
  - **Verify**: Loading spinners/indicators appear during API calls
  - **Check**: `isLoading` state, `Loader2` component usage
  - **Note**: Convergence progress bar shows background calculation status


## Backend Worker Testing

**Verify Redis/RQ background job processing**

- Monitor Redis queue to verify background jobs are enqueued where expected
  - ‚úÖ **VIABLE** - Redis/RQ used for background tasks (`worker.py`, `app/core/queue.py`, `app/tasks.py`)
  - **How to test**: 
    1. Install Redis CLI: `redis-cli`
    2. Connect: `redis-cli -h localhost -p 6379`
    3. Monitor queue: `KEYS rq:*` or use RQ dashboard
    4. Create a new session (triggers `run_deep_deduplication`); make comparisons (every 5 duels triggers in-process `process_ranking_update`, not RQ); global updates use `run_global_ranking_update` via queue
  - **Verify**: Deduplication and global ranking jobs appear in `rq:queue:default`; per-session BT updates run in-process via FastAPI `BackgroundTasks`
  - **Check**: `task_queue.enqueue(run_deep_deduplication, ...)` on session create; `task_queue.enqueue(run_global_ranking_update, artist)` when global update due
  - **Tools**: `rq-dashboard` for visual monitoring: `pip install rq-dashboard && rq-dashboard`

- Check that workers are processing jobs without failures (check logs for errors)
  - ‚úÖ **VIABLE** - Worker logs should show processing status
  - **How to test**: 
    1. Start worker: `python worker.py` (or `rq worker`)
    2. Make comparisons, watch worker logs
    3. Check for errors/exceptions
  - **Verify**: Jobs complete successfully, no exceptions
  - **Check**: Worker logs show "Job completed" messages
  - **Note**: Check both worker stdout and application logs

- Test job retry logic: simulate a failed calculation and verify it retries appropriately
  - ‚ö†Ô∏è **NEEDS VERIFICATION** - RQ has retry logic but may need configuration
  - **How to test**: 
    1. Temporarily break BT calculation (e.g., divide by zero)
    2. Submit comparison, check if job retries
    3. Verify retry count/backoff
  - **Verify**: Failed jobs retry with exponential backoff
  - **Check**: RQ job decorators may have `@retry` or similar
  - **Note**: May need to configure retry policy in `worker.py`

- Verify convergence tracking updates correctly (0% ‚Üí 100%) as the Bradley-Terry algorithm runs
  - ‚úÖ **VIABLE** - Convergence calculated in backend, returned in API
  - **How to test**: 
    1. Make comparisons, monitor `convergence_score` in API responses
    2. Check `GET /sessions/{id}` response
    3. Verify score increases from 0% toward 100%
  - **Verify**: Convergence increases with more comparisons
  - **Check**: Backend calculates convergence in `app/tasks.py` or ranking logic
  - **Note**: Frontend displays in progress bar (`RankingWidget`)

- Test performance: measure how long calculations take for 50, 100, and 200 song sessions
  - ‚úÖ **VIABLE** - Can measure worker processing time
  - **How to test**: 
    1. Create sessions with 50, 100, 200 songs
    2. Make 20 comparisons each
    3. Measure time from comparison submission to convergence update
    4. Use Redis/RQ monitoring or add timing logs
  - **Verify**: Calculations complete in reasonable time (<5s for 50 songs, <15s for 200)
  - **Check**: Worker logs with timestamps, or add `time.time()` measurements
  - **Note**: BT MM algorithm typically converges in <100 iterations

- Check that completed jobs are cleaned up from Redis to prevent memory bloat
  - ‚ö†Ô∏è **NEEDS VERIFICATION** - RQ should auto-clean but verify
  - **How to test**: 
    1. Make many comparisons, let jobs complete
    2. Check Redis: `redis-cli KEYS rq:*`
    3. Verify old jobs are removed
  - **Verify**: Completed jobs don't accumulate
  - **Check**: RQ default TTL is 500 seconds, may need adjustment
  - **Note**: May need to configure `result_ttl` in RQ queue settings


## Database Testing

**Validate data integrity and Row Level Security**

- Verify all comparisons are stored correctly in the `comparisons` table with accurate timestamps
  - ‚úÖ **VIABLE** - Comparisons stored via `POST /sessions/{id}/comparisons`
  - **How to test**: 
    1. Make comparisons, check Supabase dashboard
    2. Query: `SELECT * FROM comparisons WHERE session_id = '...' ORDER BY created_at`
    3. Verify: `song_a_id`, `song_b_id`, `winner_id`, `is_tie`, `created_at` all populated
  - **Verify**: All fields correct, timestamps sequential
  - **Check**: Supabase SQL Editor or use `supabase_client` in backend

- Check that `sessions`, `songs`, and `artist_stats` tables have proper foreign key relationships
  - ‚úÖ **VIABLE** - Can inspect database schema
  - **How to test**: 
    1. Supabase Dashboard ‚Üí Table Editor ‚Üí Check foreign keys
    2. Verify: `comparisons.session_id` ‚Üí `sessions.id`
    3. Verify: `comparisons.song_a_id` ‚Üí `songs.id`
    4. Verify: `songs` linked to sessions properly
  - **Verify**: Foreign keys exist, CASCADE rules configured
  - **Check**: Schema in `supabase_global_leaderboard.sql` or migrations

- Test Row Level Security: attempt to access another user's session data (should fail)
  - ‚ö†Ô∏è **NEEDS VERIFICATION** - RLS mentioned but policies may not be fully configured
  - **How to test**: 
    1. Create session as User A, note session_id
    2. Log in as User B
    3. Try: `GET /sessions/{user_a_session_id}` via API or direct SQL
    4. Should fail with 403/404
  - **Verify**: Cannot access other users' data
  - **Check**: Supabase Dashboard ‚Üí Authentication ‚Üí Policies
  - **Note**: `supabase_feedback.sql` shows RLS enabled for feedback table, check sessions table
  - **SQL Check**: `SELECT * FROM pg_policies WHERE tablename = 'sessions';`

- Verify cascade deletes work properly: delete a session and confirm related comparisons are also deleted
  - ‚úÖ **VIABLE** - `DELETE /sessions/{id}` endpoint exists
  - **How to test**: 
    1. Create session, make 5 comparisons
    2. Delete session via UI or API
    3. Check database: `SELECT * FROM comparisons WHERE session_id = '...'`
    4. Should return 0 rows
  - **Verify**: Comparisons deleted when session deleted
  - **Check**: Database foreign key CASCADE rules, or backend handles deletion
  - **Note**: May need to verify CASCADE DELETE is configured in schema

- Test database performance with a large dataset (500+ songs, 1000+ comparisons)
  - ‚úÖ **VIABLE** - Can create large test dataset
  - **How to test**: 
    1. Create session with 500 songs (may need script to generate)
    2. Make 1000+ comparisons (can automate or do manually)
    3. Measure query times: `EXPLAIN ANALYZE SELECT ...`
    4. Check API response times
  - **Verify**: Queries complete in <1s, no timeouts
  - **Check**: Database indexes on `session_id`, `song_a_id`, `song_b_id` in comparisons table
  - **Tools**: Use `EXPLAIN ANALYZE` in Supabase SQL Editor

- Run SQL queries to check for data anomalies: duplicate songs within a session, orphaned records, null values where they shouldn't exist
  - ‚úÖ **VIABLE** - Can write SQL queries to check data quality
  - **How to test**: Run these queries in Supabase SQL Editor:
    ```sql
    -- Duplicate songs in session
    SELECT session_id, song_id, COUNT(*) 
    FROM songs 
    GROUP BY session_id, song_id 
    HAVING COUNT(*) > 1;
    
    -- Orphaned comparisons (session deleted)
    SELECT c.* FROM comparisons c
    LEFT JOIN sessions s ON c.session_id = s.id
    WHERE s.id IS NULL;
    
    -- Null values in required fields
    SELECT * FROM comparisons WHERE song_a_id IS NULL OR song_b_id IS NULL;
    ```
  - **Verify**: No duplicates, no orphans, no nulls in required fields
  - **Check**: Data integrity maintained across all tables


## Social Sharing Testing

**Test share card generation and display**

- Generate a share card for a completed ranking and verify it displays your top 10 songs correctly
  - ‚úÖ **VIABLE** - `ShareVisual` component and `ShareButton` exist
  - **How to test**: 
    1. Complete ranking session
    2. Click "Share" button
    3. Verify top 10 songs displayed correctly
  - **Verify**: Songs 1-10 shown in order, correct names/artists
  - **Check**: `ShareVisual.tsx` renders top 10: `songs.slice(0, 10)` (preview). Image is generated by backend.
  - **Note**: Backend `POST /generate-receipt` (`app/api/v1/image_generation.py`) generates the PNG; frontend `ShareButton` + `lib/share-actions.ts` call it and then Web Share API or download.

- Test card rendering on different devices and verify image quality is acceptable
  - ‚úÖ **VIABLE** - Receipt image is generated server-side (backend controls dimensions)
  - **How to test**: 
    1. Generate card on desktop
    2. Test on mobile device
    3. Check image quality/resolution
  - **Verify**: Image is clear, text readable, proper dimensions
  - **Check**: Backend `image_generation.py` renders receipt; `ShareVisual` in frontend is layout reference. Receipt is 1080px-wide style.
  - **Note**: Test actual image from `/generate-receipt` on different devices

- Verify the card includes proper branding, formatting, and readable text
  - ‚úÖ **VIABLE** - `ShareVisual` has branding and formatting
  - **How to test**: Generate card, visually inspect
  - **Verify**: 
    - "SongRanker" header visible
    - Receipt-style formatting
    - Barcode pattern at bottom
    - Date/time displayed
  - **Check**: Component includes header, song list, barcode (`ShareVisual.tsx`)

- Test sharing the card link on social media platforms (Instagram Stories, Twitter/X, Facebook) and verify it displays correctly
  - ‚úÖ **VIABLE** - Card is generated as image by backend; `ShareButton` uses Web Share API when available, else download
  - **How to test**: 
    1. Generate card (backend returns PNG), then share or download
    2. Upload to Instagram Stories, Twitter, Facebook
    3. Verify displays correctly
  - **Verify**: Image displays properly on each platform
  - **Check**: `ShareButton` uses `navigator.share` + `files: [file]` when `navigator.canShare({ files: [file] })`, else download link
  - **Note**: Web Share API works on mobile; desktop typically gets download fallback

- Check that the share card URL is unique and doesn't expose sensitive session data
  - ‚úÖ **VIABLE** - Share flow does not expose session in URL; image is generated via POST to `/generate-receipt` with song list in body
  - **How to test**: 
    1. Generate card; confirm share is via file (Web Share or download), not a public URL
    2. Inspect any share link for session IDs or sensitive data
  - **Verify**: No session IDs or user IDs in share payload/URL; only song list and order/date sent to backend for image
  - **Check**: `ShareButton` and `share-actions.ts` send `songs`, `orderId`, `dateStr`, `timeStr` to backend; no session ID required

- Test edge cases: songs with very long titles, special characters, or emojis in the share card
  - ‚úÖ **VIABLE** - Can test with real data
  - **How to test**: 
    1. Create session with songs like:
       - Very long title: "This Is A Very Long Song Title That Might Break The Layout"
       - Special chars: "Song (feat. Artist) - Remastered 2024"
       - Emojis: "Song üéµ üé∂"
    2. Generate share card
  - **Verify**: Text truncates properly, no layout breaks, special chars display
  - **Check**: `ShareVisual` component handles text overflow
  - **Note**: May need CSS `text-overflow: ellipsis` or similar


## Error Handling Testing

**Verify graceful degradation and error messages**

- Test with no internet connection and verify appropriate error messages appear
  - ‚úÖ **VIABLE** - Error handling exists (`ErrorBanner` component)
  - **How to test**: 
    1. Disconnect WiFi/Ethernet
    2. Try to search, create session, make comparison
    3. Verify error banner appears
  - **Verify**: User-friendly error message, no crashes
  - **Check**: `fetchBackend()` catches `TypeError` and shows `ErrorBanner`
  - **Note**: Error banner shows "Cannot reach backend" message

- Simulate backend downtime and verify the frontend handles it gracefully
  - ‚úÖ **VIABLE** - Can stop backend server
  - **How to test**: 
    1. Stop FastAPI server (`uvicorn` process)
    2. Try API operations (search, create session, etc.)
    3. Verify graceful error handling
  - **Verify**: Error messages shown, no infinite loading, UI remains functional
  - **Check**: `fetchBackend()` handles connection errors, shows banner
  - **Note**: Frontend should degrade gracefully, allow retry

- Test invalid session IDs and verify proper 404 or error handling
  - ‚úÖ **VIABLE** - Can test with fake UUIDs
  - **How to test**: 
    1. Try: `GET /sessions/00000000-0000-0000-0000-000000000000`
    2. Or use invalid format: `GET /sessions/invalid-id`
    3. Verify proper error response
  - **Verify**: 404 error or clear error message
  - **Check**: Backend should return `HTTPException(status_code=404)`
  - **Note**: Frontend should handle 404 gracefully

- Try to submit malformed data (empty comparisons, invalid song IDs) and verify validation
  - ‚úÖ **VIABLE** - FastAPI has Pydantic validation
  - **How to test**: 
    1. Use browser DevTools or Postman
    2. Send: `POST /sessions/{id}/comparisons` with:
       - Empty `song_a_id`
       - Invalid UUID format
       - Missing required fields
    3. Verify validation errors
  - **Verify**: 422 validation error with details
  - **Check**: Pydantic schemas in `app/schemas/session.py` validate input
  - **Note**: FastAPI automatically validates request bodies

- Test API timeout scenarios and verify the user gets clear feedback
  - ‚ö†Ô∏è **NEEDS VERIFICATION** - May need to configure timeout handling
  - **How to test**: 
    1. Simulate slow backend (add delay in endpoint)
    2. Make API call, let it timeout
    3. Verify timeout error handling
  - **Verify**: Timeout error shown, user can retry
  - **Check**: `fetch()` API has default timeout, may need `AbortController`
  - **Note**: May need to add explicit timeout handling

- Check browser console for any unhandled JavaScript errors during normal usage
  - ‚úÖ **VIABLE** - Browser DevTools Console
  - **How to test**: 
    1. Open DevTools Console
    2. Perform all normal operations
    3. Check for red errors (warnings OK)
  - **Verify**: No unhandled errors, only expected warnings
  - **Check**: React errors, API errors, undefined values
  - **Note**: Some warnings (like React keys) are acceptable


## Cross-Browser and Performance Testing

**Ensure compatibility and speed across platforms**

- Test on Chrome, Firefox, Safari, and Edge to verify consistent behavior
  - ‚úÖ **VIABLE** - Standard browser testing
  - **How to test**: 
    1. Install all browsers
    2. Test core flows: search, rank, share
    3. Check for visual/functional differences
  - **Verify**: Consistent behavior across browsers
  - **Check**: CSS compatibility, JavaScript features (fetch, async/await)
  - **Note**: Safari may have different behavior with Web Share API

- Test on iOS Safari and Android Chrome for mobile compatibility
  - ‚úÖ **VIABLE** - Mobile device testing
  - **How to test**: 
    1. Use actual devices or browser DevTools mobile emulation
    2. Test touch interactions, scrolling, layout
    3. Verify responsive design works
  - **Verify**: Mobile layout works, touch targets adequate size
  - **Check**: Tailwind responsive classes, touch event handling
  - **Note**: Web Share API works better on mobile devices

- Measure page load times and verify initial load is under 3 seconds
  - ‚úÖ **VIABLE** - Browser DevTools Performance/Lighthouse
  - **How to test**: 
    1. Open DevTools ‚Üí Lighthouse tab
    2. Run performance audit
    3. Check First Contentful Paint, Time to Interactive
  - **Verify**: Initial load < 3s, good Lighthouse score
  - **Check**: Next.js optimizations, image loading, font loading
  - **Tools**: Lighthouse, WebPageTest, Chrome DevTools Performance

- Test with browser extensions (ad blockers, privacy tools) and verify functionality isn't broken
  - ‚úÖ **VIABLE** - Install extensions and test
  - **How to test**: 
    1. Install uBlock Origin, Privacy Badger, etc.
    2. Test app functionality
    3. Check if API calls blocked
  - **Verify**: App still works, API calls not blocked
  - **Check**: CORS headers, API endpoint accessibility
  - **Note**: Some extensions may block external API calls

- Check for memory leaks: complete several ranking sessions in one browser session and monitor memory usage
  - ‚úÖ **VIABLE** - Browser DevTools Memory profiler
  - **How to test**: 
    1. Open DevTools ‚Üí Memory tab
    2. Take heap snapshot before sessions
    3. Complete 5+ ranking sessions
    4. Take another snapshot, compare
  - **Verify**: Memory doesn't grow unbounded
  - **Check**: Event listeners cleaned up, state cleared between sessions
  - **Note**: React should handle cleanup, but verify `useEffect` cleanup functions

- Verify service workers or caching (SWR pattern) reduce load times for returning users
  - ‚úÖ **VIABLE** - SWR pattern implemented (`localStorage` caching)
  - **How to test**: 
    1. First visit: measure load time
    2. Close browser, reopen
    3. Measure load time again (should be faster)
  - **Verify**: Session list loads instantly from cache
  - **Check**: `SessionSelector` uses `localStorage` for SWR pattern
  - **Note**: Next.js may have service worker, check `next.config.ts`


## Security Testing

**Validate authentication and data protection**

- Test session hijacking prevention: verify session tokens are secure and HTTP-only
  - ‚úÖ **VIABLE** - Supabase Auth handles this
  - **How to test**: 
    1. Log in, check browser DevTools ‚Üí Application ‚Üí Cookies
    2. Verify Supabase auth tokens are HttpOnly, Secure flags set
    3. Check token expiration times
  - **Verify**: Tokens not accessible via JavaScript, HTTPS only
  - **Check**: Supabase Auth configuration, cookie settings
  - **Note**: Supabase handles token security, but verify configuration

- Check for SQL injection vulnerabilities in search queries and user inputs
  - ‚úÖ **VIABLE** - Backend uses parameterized queries
  - **How to test**: 
    1. Try search: `'; DROP TABLE sessions; --`
    2. Try in song names, session creation
    3. Verify no SQL execution
  - **Verify**: Inputs sanitized, no SQL injection possible
  - **Check**: Supabase client uses parameterized queries (automatic)
  - **Note**: FastAPI + Supabase client should prevent SQL injection

- Verify CORS settings prevent unauthorized cross-origin requests
  - ‚úÖ **VIABLE** - FastAPI CORS configuration
  - **How to test**: 
    1. Check backend CORS settings in `app/main.py`
    2. Try API call from different origin (should fail if not allowed)
    3. Verify `Access-Control-Allow-Origin` headers
  - **Verify**: Only allowed origins can access API
  - **Check**: FastAPI `CORSMiddleware` configuration
  - **Note**: Should allow frontend domain, block others

- Test XSS prevention: try entering `<script>alert('test')</script>` in song search and verify it's sanitized
  - ‚úÖ **VIABLE** - React automatically escapes content
  - **How to test**: 
    1. Try searching: `<script>alert('XSS')</script>`
    2. Check if script executes (should not)
    3. Verify text is displayed as plain text, not executed
  - **Verify**: Scripts don't execute, text is escaped
  - **Check**: React's JSX automatically escapes content
  - **Note**: If using `dangerouslySetInnerHTML`, verify sanitization

- Verify API keys (MusicBrainz, Supabase) are not exposed in frontend code
  - ‚úÖ **VIABLE** - Check frontend code and environment variables
  - **How to test**: 
    1. Check `lib/api.ts`, `lib/supabase.ts` for hardcoded keys
    2. View page source, check for exposed keys
    3. Check browser DevTools ‚Üí Network ‚Üí Response headers
  - **Verify**: No API keys in frontend code
  - **Check**: Only `NEXT_PUBLIC_*` env vars exposed (Supabase anon key OK)
  - **Note**: Supabase anon key is safe to expose (RLS protects data)
  - **Warning**: Backend API keys should NEVER be in frontend

- Test rate limiting on API endpoints to prevent abuse
  - ‚úÖ **VIABLE** - Rate limiting exists (`slowapi`, `app/core/limiter.py`, `@limiter.limit()` on multiple routes)
  - **How to test**: 
    1. Make rapid API calls (e.g. search 30+ times in a minute, or create session 10+ times)
    2. Check if requests are throttled
    3. Verify rate limit errors returned
  - **Verify**: Rate limits enforced, abuse prevented
  - **Check**: Search 30/min, create session 10/min, feedback 5/min, image generation 5/min, leaderboard 60/min
  - **Note**: Each endpoint has its own limit; see routers in `app/api/v1/`.


## Missing Checks \& Recommendations

**Additional areas to investigate**

- **Authentication system**: If user accounts exist, test signup, login, logout, password reset flows
  - ‚úÖ **VIABLE** - Supabase Auth implemented (`AuthProvider`, `AuthModal`)
  - **How to test**: 
    1. Test signup: new email, verify confirmation email
    2. Test login: email/password, Google OAuth
    3. Test logout: verify session cleared
    4. Test password reset: use "Forgot password" flow
  - **Verify**: All auth flows work correctly
  - **Check**: `AuthModal.tsx` has login/signup modes, Google OAuth
  - **Note**: Password reset may need Supabase configuration

- **Analytics tracking**: Verify user behavior analytics (if implemented) are capturing events correctly
  - ‚ö†Ô∏è **NOT IMPLEMENTED** - No analytics visible in code
  - **Recommendation**: Consider adding analytics (Google Analytics, Plausible, etc.)
  - **If added**: Test event tracking for: session creation, comparisons made, shares generated
  - **Note**: Privacy-conscious option: Plausible or self-hosted

- **Accessibility (a11y)**: Test with screen readers, keyboard-only navigation, and color contrast tools
  - ‚ö†Ô∏è **NEEDS VERIFICATION** - Some a11y features may exist but need testing
  - **How to test**: 
    1. Use screen reader (NVDA, VoiceOver)
    2. Navigate with keyboard only (Tab, Enter, Arrow keys)
    3. Check color contrast with tools (WebAIM Contrast Checker)
  - **Verify**: All functionality accessible via keyboard, screen reader friendly
  - **Check**: Keyboard shortcuts exist (`RankingWidget` has arrow key support)
  - **Note**: May need ARIA labels, focus management improvements

- **Edge case: empty albums**: Test what happens if a selected album has 0 songs returned from MusicBrainz
  - ‚úÖ **VIABLE** - Can test with albums that have no tracks
  - **How to test**: 
    1. Find album with 0 tracks (or mock API response)
    2. Select album, try to create session
    3. Verify graceful handling
  - **Verify**: Error message shown, or album filtered out
  - **Check**: `getReleaseGroupTracks()` handles empty arrays
  - **Note**: Backend may return empty `tracks: []`, frontend should handle

- **Concurrent user testing**: Have multiple people use the app simultaneously and verify no data conflicts
  - ‚úÖ **VIABLE** - Can test with multiple users
  - **How to test**: 
    1. Have 2+ users create sessions simultaneously
    2. Make comparisons at same time
    3. Verify no data corruption, sessions remain separate
  - **Verify**: Each user's data isolated, no conflicts
  - **Check**: Database transactions, session isolation
  - **Note**: Should work if RLS configured correctly

- **Data export**: Check if users can export their rankings (CSV, JSON) for personal use
  - ‚ùå **NOT IMPLEMENTED** - No export functionality visible
  - **Recommendation**: Add export button in `Leaderboard` component
  - **Implementation idea**: 
    ```typescript
    const exportCSV = () => {
      const csv = songs.map((s, i) => `${i+1},${s.name},${s.artist}`).join('\n');
      downloadFile(csv, 'rankings.csv');
    };
    ```
  - **Value**: Users may want to save/share rankings outside app

- **Undo functionality**: Test if users can undo a comparison choice or restart a session
  - ‚ùå **NOT IMPLEMENTED** - No undo visible
  - **Current**: Users can delete session and start over
  - **Recommendation**: Add "Undo last comparison" button
  - **Implementation complexity**: Medium - need to track comparison history, revert Elo/BT calculations
  - **Alternative**: "Restart session" button to reset comparisons but keep songs

- **Global leaderboards (Phase 8)**: Once implemented, verify aggregate rankings are calculated correctly across users
  - ‚úÖ **PARTIALLY IMPLEMENTED** - Global leaderboard exists (`GlobalLeaderboard` component)
  - **How to test**: 
    1. Have multiple users rank same artist
    2. Check global leaderboard for that artist
    3. Verify aggregate rankings make sense
  - **Verify**: Rankings aggregated correctly, caching works
  - **Check**: `GET /leaderboard/{artist}` endpoint, Redis caching
  - **Note**: Phase 8 in progress, may need more testing

- **Backup and recovery**: Verify database backups exist and test restoring from a backup
  - ‚ö†Ô∏è **SUPABASE MANAGED** - Supabase handles backups automatically
  - **How to test**: 
    1. Check Supabase Dashboard ‚Üí Database ‚Üí Backups
    2. Verify backup schedule configured
    3. Test point-in-time recovery (if available on plan)
  - **Verify**: Backups exist, can restore if needed
  - **Check**: Supabase project settings, backup retention policy
  - **Note**: Free tier may have limited backups, paid plans have better options

- **Mobile app considerations**: If planning mobile apps, test API compatibility with iOS/Android clients
  - ‚ö†Ô∏è **FUTURE** - Not currently planned but API should work
  - **How to test**: 
    1. Use mobile app (if built) or test API with Postman from mobile
    2. Verify API responses work with mobile clients
    3. Check authentication flow on mobile
  - **Verify**: API is mobile-friendly, authentication works
  - **Note**: FastAPI OpenAPI docs can generate mobile SDKs
  - **Recommendation**: Test API with mobile HTTP clients before building apps

- **Load testing**: Use tools like Apache JMeter or Locust to simulate 100+ concurrent users
  - ‚úÖ **VIABLE** - Locust file exists (`locustfile.py` in backend)
  - **How to test**: 
    1. Install Locust: `pip install locust`
    2. Run: `locust -f locustfile.py`
    3. Simulate 100+ users, monitor performance
  - **Verify**: System handles load, no crashes, reasonable response times
  - **Check**: `locustfile.py` has test scenarios
  - **Note**: Test both frontend (Next.js) and backend (FastAPI) under load

- **Internationalization**: Test with non-English song titles (Japanese, Arabic, Cyrillic scripts) to verify proper display
  - ‚úÖ **VIABLE** - Can test with real data
  - **How to test**: 
    1. Search for artists with non-English names:
       - Japanese: "ÂÆáÂ§öÁî∞„Éí„Ç´„É´" (Utada Hikaru)
       - Arabic: "ÿ£ŸÖ ŸÉŸÑÿ´ŸàŸÖ" (Umm Kulthum)
       - Cyrillic: "–ö–∏–Ω–æ" (Kino)
    2. Verify titles display correctly in UI
  - **Verify**: Unicode characters render properly, no encoding issues
  - **Check**: Font supports Unicode (Geist font should), database uses UTF-8
  - **Note**: May need to test deduplication with non-ASCII characters

<div align="center">‚ÅÇ</div>

[^1]: PROJECT_SUMMARY.md

